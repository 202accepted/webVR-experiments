<!doctype html>
<html>
<head>
   <title>11 - Transitions</title>
   <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no,user-scalable=no,maximum-scale=1">
   <script src="bower_components/aframe/dist/aframe-v0.2.0.min.js"></script>
   <script src="bower_components/Keypress/keypress.js"></script>
   <script src="bower_components/fetch/fetch.js"></script>
   <script src="js/global-functions.js"></script>
   <style>
   *{
      /*cursor: none;*/
   }
   </style>

</head>
<body>

   <a-scene>

      <!--

      Credits

      -->

      <!--
         Dark Blue:  006ba6
         Blue:       0496ff
         Yellow:     ffbc42
         Pink:       d81159
         Plum:       8f2d56
      -->

      <a-assets>
         <a-asset-item id="mv-obj" src="assets/models/monument-valley.obj"></a-asset-item>
         <a-asset-item id="mv-mtl" src="assets/models/monument-valley.mtl"></a-asset-item>

         <img id="ms-1" src="assets/spherical/main-squeeze.jpg">
         <img id="ms-2" src="assets/spherical/main-squeeze-2.jpg">

      </a-assets>

      <!-- Global Settings -->
      <a-sky color="#64e6ff"></a-sky>



      <!-- World Elements -->
      <a-entity id="world">

         <a-entity obj-model="obj: #mv-obj; mtl: #mv-mtl" scale=".3 .3 .3" position="6 -.3 -13"></a-entity>
         <a-sphere radius="2.1" material="src: #ms-1; side: double" position="5.281238208730752 1.7 13.320115124771668" rotation="0 90 0"></a-sphere>
         <a-sphere radius="2.1" material="src: #ms-2; side: double" position="0.3638128680856906 1.7 14.139963967279039" rotation="0 0 0"></a-sphere>

      </a-entity>

      <!-- Human Camera -->
      <a-camera id="human-camera" position="0 1.7 0" wasd-controls="fly:true" active="true" near=".05">
         <a-entity cursor="fuse: true; maxDistance: 50; timeout: 500" position="0 0 -2" geometry="primitive: plane; height: .05; width: .05"  material="color: #fff"></a-entity>
      </a-camera>

   </a-scene>


   <script>

      var settings = null;

      fetchSettings();

      function fetchSettings(){
         fetch('assets/11/11-settings.json').then(function(response){
            response.json().then(function(responseData){
               settings = responseData;
            });
         });
      }

      var intervalID = window.setInterval(checkSettingsCallback, 1500);

      /*
         Setup global variables
      */
      var scene = document.querySelector('a-scene');
      var world = document.querySelector('#world');
      var camera = document.querySelector('a-camera');
      var cameraLastPosition = camera.getAttribute('position');

      /*
         Add event listener to run after scene is loaded
      */
      scene.addEventListener('loaded', function(){

         devTools();

         setCamera(camera, settings.cameraPosition);

         placeTransitionOrbs([
            {x: -5.499636956049418,    y: 6.3,     z: -12.971373578044469},
            {x: 12.709765049944446,    y: 6.6,     z: -8.388245758668296},
            {x: 17.54385488277026,     y: 6.3,     z: -12.965917521979673},
            {x: 19.155885460376894,    y: 0,       z: -26.4025057439792},
            {x: -2.8239695631562753,   y: 0,       z: -7.139200987208032},
            {x: 8.900519242752663,     y: 0,       z: -1.9215587285872922},
            {x: -4.3808164081879015,   y: 0,       z: -17.19795420116629},
            {x: -4.183515004950278,    y: 0,       z: -24.184966522656342},
            {x: 4.346838095657409,     y: 0,       z: -14.966443485230126},
            {x: 16.950260752918833,    y: 17.5,    z: -18.575435892985322},
            {x: 12.501794418453516,    y: 17.5,    z: -13.6169492206195},
            {x: 16.54346786694255,     y: 23.7,    z: -23.495441524818382},

         ], true);

         var targets = scene.querySelectorAll('.target')

         forEach(targets, function(el){
            el.addEventListener('click', function () {

               console.log('I was clicked!');

               setDefaultTransition(el);

            });
         });

      });

      /*
         Keylistener functions
      */
      // Setup
      var keyListener = new window.keypress.Listener();

      keyListener.simple_combo('1', function(){
         console.log('fadejump, short');
         transitionFadeJump(100, 0, 'sine', {x:1, y:2, z:5});
      });
      keyListener.simple_combo('2', function(){
         console.log('fadejump, long');
         transitionFadeJump(100, 0, 'sine', {x:1, y:2, z:5});
      });
      keyListener.simple_combo('3', function(){
         console.log('micromovements');
         transitionMicromovements({x:-5, y:1.7, z:5}, 5, 800);
      });
      keyListener.simple_combo('4', function(){
         console.log('animation');
         transitionAnimate({x:-5, y:1.7, z:5}, 1);
      });

      keyListener.simple_combo('c', function(){
         console.log(camera.getAttribute('position'));
      });

      function setCameraLastPosition(){
         cameraLastPosition = camera.getAttribute('position');
      }

      function transitionJump(position){
         camera.setAttribute('position', position);
      }

      function transitionFadeJump(duration, beginTime, easing, position){
         transitionFade(duration, beginTime, easing, function(){
            transitionJump(position);
         });
      }

      function transitionFade(duration, beginTime, easing, middleFunction){
         addEl(camera, {
            entityType: 'sphere',
            id: 'fadeSphere',
            radius: .5,
            color: '#000',
            position: '0 0 0',
            side: 'double',
            opacity: '0',
            class: 'remove',
         });

         if(middleFunction == undefined){
            middleFunction = function(){};
         }

         addAnimation(camera.querySelector('#fadeSphere'), {
            attribute: "opacity",
            begin: beginTime,
            dur: duration,
            direction: "alternate",
            easing: "ease-in-out-" + easing,
            fill: "forwards",
            from: 0,
            to: 1,
            repeat: 1,
            class: 'remove'
         }, function(){

            middleFunction();
         });
      }

      function transitionMicromovements(position, stepCount, duration){
         var oldPos = camera.getAttribute('position');
         var newPos = position;

         var steps = {
            x: (newPos.x - oldPos.x) / stepCount,
            y: (newPos.y - oldPos.y) / stepCount,
            z: (newPos.z - oldPos.z) / stepCount
         }

         var stepDuration = duration / stepCount;

         function callback(){
            return function(){
               oldPos = camera.getAttribute('position');
               newPosition = {
                  x: oldPos.x + steps.x,
                  y: oldPos.y + steps.y,
                  z: oldPos.z + steps.z
               };
               camera.setAttribute('position', newPosition);
            }
         }

         for(i = 0; i < stepCount; i++){
            console.log(i);

            setTimeout(callback(), stepDuration * (i+1));

         }

      }

      function transitionAnimate(position, speed){
         var oldPos = camera.getAttribute('position');
         var newPos = position;

         console.log(newPos);

         // Physics reminder time!
         // v = x / t
         // thus, t = x / v

         function subtractPositionObjects(objA, objB){
            var x = objA.x - objB.x;
            var y = objA.y - objB.y;
            var z = objA.z - objB.z;
            return {x, y, z};
         }

         var differenceObj = subtractPositionObjects(newPos, oldPos);

         console.log(differenceObj);

         var distance = Math.sqrt(Math.pow(differenceObj.x, 2) + Math.pow(differenceObj.y, 2) + Math.pow(differenceObj.z, 2));

         console.log(distance);

         var duration = (distance / speed) * 1000;

         console.log(duration);

         addAnimation(camera, {
            attribute: 'position',
            dur: duration,
            easing: 'linear',
            to: newPos.x + ' ' + newPos.y + ' ' + newPos.z
         }, true);
      }

      function addAnimation(insertEl, animationParameters, removeBool, middleFunction){
         // Model:
         // var animationParameters = {
         //    attribute: "opacity",
         //    begin: 2000,
         //    dur: 1000,
         //    direction: "alternate",
         //    easing: "ease-in-out-sine",
         //    fill: "forwards",
         //    from: 0,
         //    to: 1,
         //    repeat: 1
         // }

         // Create a new animation element
         var newEl = document.createElement('a-animation');

         // Set the attributes of the element if they were passed in the animationParameters{}
         if(animationParameters.attribute != undefined)
            newEl.setAttribute('attribute', animationParameters.attribute);

         if(animationParameters.begin != undefined)
            newEl.setAttribute('begin', animationParameters.begin);

         if(animationParameters.dur != undefined)
            newEl.setAttribute('dur', animationParameters.dur);

         if(animationParameters.direction != undefined)
            newEl.setAttribute('direction', animationParameters.direction);

         if(animationParameters.easing != undefined)
            newEl.setAttribute('easing', animationParameters.easing);

         if(animationParameters.fill != undefined)
            newEl.setAttribute('fill', animationParameters.fill);

         if(animationParameters.from != undefined)
            newEl.setAttribute('from', animationParameters.from);

         if(animationParameters.to != undefined)
            newEl.setAttribute('to', animationParameters.to);

         if(animationParameters.repeat != undefined)
            newEl.setAttribute('repeat', animationParameters.repeat);

         if(animationParameters.class != undefined)
            newEl.setAttribute('class', animationParameters.class);

         if(animationParameters.id != undefined)
            newEl.setAttribute('id', animationParameters.id);

         // Add the element to the DOM
         insertEl.appendChild(newEl);

         // If there isn't a removeBool, but there is a middleFunction(), set the vars as such
         if(typeof removeBool == 'function'){
            middleFunction = removeBool;
            removeBool = undefined;
         }else if(removeBool == true){
            var classes = newEl.getAttribute('class');
            if(classes == null){
               newEl.setAttribute('class', 'remove');
            }else{
               classes += ' remove';
               newEl.setAttribute('class', classes);
            }
         }

         // If the remove boolean is set to true (or default is to remove), then remove the animation element after the animation runs
         if(removeBool == undefined || removeBool == true){

            newEl.addEventListener('animationend', function() {
               var parentNode = this.parentNode;
               var removeNode = parentNode.querySelector('.remove');
               parentNode.removeChild(removeNode);
               console.log('Animation removed with attribute: ' + animationParameters.attribute);

               if(parentNode.getAttribute('class') == 'remove'){
                  removeNode = parentNode.parentNode.querySelector('.remove');
                  parentNode.parentNode.removeChild(removeNode);
               }
            });

         }

         // If the middleFunction is defined, then start it with the animation TODO: add wait timer
         if(middleFunction != undefined){

            // To get rid of running each repeat
            middleFunctionRun = false;

            newEl.addEventListener('animationstart', function() {
               if(middleFunctionRun == false){
                  setTimeout(function(){
                     middleFunction();
                  }, animationParameters.dur);
                  middleFunctionRun = true;
               }
            });
         }
      }

      function addEl(insertEl, elParameters){
         // Model follows a-entitiy attributes

         // Create a new entity element
         var newEl = document.createElement('a-' + elParameters.entityType);

         // Set the attributes of the element if they were passed in the elParameters{}


         if(elParameters.id != undefined)
            newEl.setAttribute('id', elParameters.id);

         if(elParameters.class != undefined)
            newEl.setAttribute('class', elParameters.class);

         if(elParameters.radius != undefined)
            newEl.setAttribute('radius', elParameters.radius);

         if(elParameters.color != undefined)
            newEl.setAttribute('color', elParameters.color);

         if(elParameters.position != undefined)
            newEl.setAttribute('position', elParameters.position);

         if(elParameters.side != undefined)
            newEl.setAttribute('side', elParameters.side);

         if(elParameters.opacity != undefined)
            newEl.setAttribute('opacity', elParameters.opacity);



         // Add the element to the DOM
         insertEl.appendChild(newEl);

         // If the middleFunction is defined, then start it with the animation TODO: add wait timer
         // if(nestedEl != undefined){
         //    nestedEl
         // }

      }

      /*
      Places transition orbs around the world based on a given array. Adds the height of the user by default (pass 'false' to not add height).
      */
      function placeTransitionOrbs(orbPositions, addHeight){
         for(i = 0; i < orbPositions.length; i++){

            if(addHeight == true || addHeight == undefined){
               orbPositions[i].y += settings.height;
            }

            addEl(world, {
               entityType: 'sphere',
               radius: .3,
               color: '#333',
               opacity: .7,
               position: orbPositions[i],
               class: 'target'
            })
         };
      }

      function setDefaultTransition(el){

         newPos = el.getAttribute('position');

         switch(settings.transition){
            case 'Jump':
               transitionJump(newPos);
               break;
            case 'Fade Jump':
               transitionFadeJump(400, 0, 'sine', newPos);
               break;
            case 'Fade Jump Short':
               transitionFadeJump(200, 0, 'sine', newPos);
               break;
            case 'Fade Jump Long':
               transitionFadeJump(1000, 0, 'sine', newPos);
               break;
            case 'Micro-Movements':
               transitionMicromovements(newPos, 5, 800);
               break;
            case 'Micro-Movements Short':
               transitionMicromovements(newPos, 10, 800);
               break;
            case 'Micro-Movements Long':
               transitionMicromovements(newPos, 3, 800);
               break;
            case 'Animate':
               transitionAnimate(newPos, 10);
               break;
            case 'Animate Short':
               transitionAnimate(newPos, 100);
               break;
            case 'Animate Long':
               transitionAnimate(newPos, 1);
               break;
            default:
               break;
         }

      }

   </script>
   </body>
</html>
